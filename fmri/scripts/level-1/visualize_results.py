#!/usr/bin/env python3
"""
Visualization script for surface-based GLM results.

Load and visualize beta maps, design matrices, and summary statistics
from the pkl output files generated by surface_1stlvl_analysis.py.
"""

import argparse
import os
import pickle as pkl
import sys

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from matplotlib.gridspec import GridSpec


def load_results(pkl_path: str) -> dict:
    """Load results from pickle file."""
    with open(pkl_path, 'rb') as f:
        data = pkl.load(f)
    return data


def get_surface_paths(derivatives_root: str, subID: str) -> tuple[str, str]:
    """Get left and right hemisphere inflated surface paths."""
    freesurfer_surf = os.path.join(
        derivatives_root, 'fmriprep-24.0.1', 'sourcedata', 'freesurfer',
        f'sub-{subID}', 'surf'
    )
    left_surf = os.path.join(freesurfer_surf, 'lh.inflated')
    right_surf = os.path.join(freesurfer_surf, 'rh.inflated')
    return left_surf, right_surf


def summarize_results(data: dict, pkl_path: str):
    """Print summary statistics of the results."""
    print(f"\n{'='*70}")
    print(f"RESULTS SUMMARY: {os.path.basename(pkl_path)}")
    print(f"{'='*70}\n")

    glm_type = data.get('glm_type', 'unknown')
    print(f"GLM Type: {glm_type}")

    if 'total_runs' in data:
        print(f"Total runs available: {data['total_runs']}")

    if 'runs_excluded' in data:
        excluded = data['runs_excluded']
        if excluded:
            print(f"Runs excluded: {excluded}")
        else:
            print("Runs excluded: None")

    if 'runs_kept' in data:
        print(f"Runs used: {data['runs_kept']}")

    # Handle Simple GLM output
    if glm_type == 'simple' and 'contrast_results' in data:
        contrast_results = data['contrast_results']
        print(f"\nContrasts computed: {len(contrast_results)}")
        print("-" * 40)
        for name, result in contrast_results.items():
            n_runs = result.get('n_runs', 'N/A')
            definition = result.get('definition', 'N/A')
            print(f"  {name}:")
            print(f"    Definition: {definition}")
            print(f"    Runs combined: {n_runs}")
            print(f"    Has effect_size: {'effect_size' in result}")
            print(f"    Has variance: {'effect_variance' in result}")
            print(f"    Has z_score: {result.get('z_score') is not None}")

    # Handle LSA/LSSM output
    else:
        n_betas = len(data.get('beta_maps', []))
        conditions = data.get('conditions', [])
        runs = data.get('runs', [])

        print(f"\nTotal beta maps: {n_betas}")

        if 'nuisance_model' in data:
            print(f"Nuisance model: {data['nuisance_model']}")

        # Unique runs in output
        if runs:
            unique_runs = sorted(set(runs))
            print(f"Runs in output: {unique_runs}")

        # Condition breakdown
        if conditions:
            print(f"\nCondition breakdown:")
            print("-" * 40)

            # For LSA/LSSM, conditions have __trial_N suffix, strip it for summary
            base_conditions = [c.split('__')[0] for c in conditions]
            condition_counts = pd.Series(base_conditions).value_counts().sort_index()

            for cond, count in condition_counts.items():
                print(f"  {cond}: {count} trials")

    # Design matrix info
    if 'design_matrices' in data:
        dm = data['design_matrices']
        if dm:
            print(f"\nDesign matrices: {len(dm)}")
            print(f"  Regressors in first matrix: {dm[0].shape[1]}")
            print(f"  Timepoints in first matrix: {dm[0].shape[0]}")
            # Show column names for simple GLM
            if glm_type == 'simple':
                cond_cols = [c for c in dm[0].columns if not c.startswith(('drift', 'motion', 'trans', 'rot', 'frame', 'constant'))]
                print(f"  Condition columns: {cond_cols}")

    # Parameters
    if 'parameters' in data:
        print(f"\nParameters:")
        for key, val in data['parameters'].items():
            print(f"  {key}: {val}")

    print()


def plot_design_matrices(data: dict, n_matrices: int = 3, save_path: str = None):
    """Plot example design matrices."""
    if 'design_matrices' not in data:
        print("No design matrices found in data.")
        return

    dm_list = data['design_matrices']
    n_to_plot = min(n_matrices, len(dm_list))

    if n_to_plot == 0:
        print("No design matrices to plot.")
        return

    fig, axes = plt.subplots(1, n_to_plot, figsize=(7 * n_to_plot, 10))

    if n_to_plot == 1:
        axes = [axes]

    for i, ax in enumerate(axes):
        dm = dm_list[i]

        # Plot as heatmap
        im = ax.imshow(dm.values, aspect='auto', cmap='RdBu_r',
                       vmin=-1, vmax=1, interpolation='nearest')

        # Labels
        ax.set_xlabel('Regressors')
        ax.set_ylabel('Timepoints (TRs)')
        ax.set_title(f'Design Matrix {i + 1}')

        # Add regressor names on top (rotated)
        if dm.shape[1] <= 30:  # Only show labels if not too many
            ax.set_xticks(range(dm.shape[1]))
            ax.set_xticklabels(dm.columns, rotation=90, fontsize=6)

    plt.colorbar(im, ax=axes[-1], label='Regressor value')
    plt.tight_layout()

    if save_path:
        plt.savefig(save_path, dpi=150, bbox_inches='tight')
        print(f"Design matrices saved to: {save_path}")
    else:
        plt.show()


def plot_beta_histogram(data: dict, save_path: str = None):
    """Plot histogram of beta values across all maps."""
    if 'beta_maps' not in data:
        print("No beta maps found in data.")
        return

    beta_maps = data['beta_maps']
    conditions = data.get('conditions', [])

    # Extract effect sizes from all beta maps
    all_betas = []
    for bm in beta_maps:
        if 'effect_size' in bm:
            effect = bm['effect_size']
            # Get data from both hemispheres
            if hasattr(effect, 'data'):
                for hemi in ['left', 'right']:
                    if hemi in effect.data.parts:
                        all_betas.extend(effect.data.parts[hemi].flatten())

    if not all_betas:
        print("Could not extract beta values.")
        return

    all_betas = np.array(all_betas)
    all_betas = all_betas[~np.isnan(all_betas)]  # Remove NaNs

    fig, axes = plt.subplots(1, 2, figsize=(12, 5))

    # Histogram
    axes[0].hist(all_betas, bins=100, edgecolor='black', alpha=0.7)
    axes[0].axvline(0, color='red', linestyle='--', linewidth=1)
    axes[0].set_xlabel('Beta value')
    axes[0].set_ylabel('Frequency')
    axes[0].set_title('Distribution of Beta Values (all vertices, all trials)')
    axes[0].text(0.02, 0.98, f'Mean: {np.mean(all_betas):.4f}\nStd: {np.std(all_betas):.4f}',
                 transform=axes[0].transAxes, verticalalignment='top',
                 fontsize=10, bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))

    # By condition (mean beta per trial)
    if conditions:
        trial_means = []
        for bm in beta_maps:
            if 'effect_size' in bm:
                effect = bm['effect_size']
                if hasattr(effect, 'data'):
                    trial_vals = []
                    for hemi in ['left', 'right']:
                        if hemi in effect.data.parts:
                            trial_vals.extend(effect.data.parts[hemi].flatten())
                    if trial_vals:
                        trial_means.append(np.nanmean(trial_vals))

        base_conds = [c.split('__')[0] for c in conditions]
        df = pd.DataFrame({'condition': base_conds, 'mean_beta': trial_means})

        # Box plot by condition
        cond_order = df.groupby('condition')['mean_beta'].mean().sort_values().index
        positions = range(len(cond_order))
        bp_data = [df[df['condition'] == c]['mean_beta'].values for c in cond_order]

        bp = axes[1].boxplot(bp_data, positions=positions, patch_artist=True)
        for patch in bp['boxes']:
            patch.set_facecolor('lightblue')

        axes[1].set_xticks(positions)
        axes[1].set_xticklabels(cond_order, rotation=45, ha='right', fontsize=8)
        axes[1].axhline(0, color='red', linestyle='--', linewidth=1)
        axes[1].set_ylabel('Mean beta (across vertices)')
        axes[1].set_title('Beta Values by Condition')

    plt.tight_layout()

    if save_path:
        plt.savefig(save_path, dpi=150, bbox_inches='tight')
        print(f"Beta histogram saved to: {save_path}")
    else:
        plt.show()


def plot_surface_beta(
    data: dict,
    trial_idx: int,
    derivatives_root: str,
    subID: str,
    save_path: str = None,
    vmax: float = None,
):
    """Plot beta map on surface for a specific trial."""
    try:
        from nilearn.plotting import plot_surf_stat_map, view_surf
        from nilearn.surface import PolyMesh
    except ImportError:
        print("nilearn plotting not available. Install with: pip install nilearn")
        return

    if 'beta_maps' not in data:
        print("No beta maps found in data.")
        return

    beta_maps = data['beta_maps']
    conditions = data.get('conditions', [])

    if trial_idx >= len(beta_maps):
        print(f"Trial index {trial_idx} out of range. Max index: {len(beta_maps) - 1}")
        return

    # Get the beta map
    bm = beta_maps[trial_idx]
    condition = conditions[trial_idx] if trial_idx < len(conditions) else f"Trial {trial_idx}"

    if 'effect_size' not in bm:
        print("No effect_size found in beta map.")
        return

    effect = bm['effect_size']

    # Load surface
    left_surf, right_surf = get_surface_paths(derivatives_root, subID)
    surf = PolyMesh(left=left_surf, right=right_surf)

    # Determine vmax if not specified
    if vmax is None:
        all_vals = []
        if hasattr(effect, 'data'):
            for hemi in ['left', 'right']:
                if hemi in effect.data.parts:
                    all_vals.extend(np.abs(effect.data.parts[hemi].flatten()))
        if all_vals:
            vmax = np.nanpercentile(all_vals, 95)
        else:
            vmax = 1.0

    # Create figure with both hemispheres
    fig = plt.figure(figsize=(16, 8))
    gs = GridSpec(2, 4, figure=fig, wspace=0.05, hspace=0.1)

    views = [
        ('left', 'lateral', gs[0, 0]),
        ('left', 'medial', gs[0, 1]),
        ('right', 'lateral', gs[1, 0]),
        ('right', 'medial', gs[1, 1]),
    ]

    for hemi, view, grid_pos in views:
        ax = fig.add_subplot(grid_pos, projection='3d')

        if hemi == 'left':
            surf_mesh = left_surf
            if hasattr(effect, 'data') and 'left' in effect.data.parts:
                stat_map = effect.data.parts['left'].flatten()
            else:
                continue
        else:
            surf_mesh = right_surf
            if hasattr(effect, 'data') and 'right' in effect.data.parts:
                stat_map = effect.data.parts['right'].flatten()
            else:
                continue

        try:
            plot_surf_stat_map(
                surf_mesh,
                stat_map,
                hemi=hemi,
                view=view,
                colorbar=False,
                vmax=vmax,
                cmap='coolwarm',
                symmetric_cbar=True,
                axes=ax,
                title=f'{hemi.capitalize()} {view}',
            )
        except Exception as e:
            print(f"Could not plot {hemi} {view}: {e}")

    # Add colorbar
    cax = fig.add_axes([0.55, 0.15, 0.35, 0.03])
    sm = plt.cm.ScalarMappable(cmap='coolwarm', norm=plt.Normalize(-vmax, vmax))
    sm.set_array([])
    cbar = fig.colorbar(sm, cax=cax, orientation='horizontal')
    cbar.set_label('Beta value')

    # Title
    fig.suptitle(f'Beta Map: {condition}', fontsize=14, y=0.98)

    if save_path:
        plt.savefig(save_path, dpi=150, bbox_inches='tight')
        print(f"Surface plot saved to: {save_path}")
    else:
        plt.show()


def plot_interactive_surface(
    data: dict,
    trial_idx: int,
    derivatives_root: str,
    subID: str,
    vmax: float = None,
):
    """Open interactive surface viewer for a specific trial."""
    try:
        from nilearn.plotting import view_surf
        from nilearn.surface import PolyMesh
    except ImportError:
        print("nilearn plotting not available.")
        return

    if 'beta_maps' not in data:
        print("No beta maps found.")
        return

    beta_maps = data['beta_maps']
    conditions = data.get('conditions', [])

    if trial_idx >= len(beta_maps):
        print(f"Trial index {trial_idx} out of range.")
        return

    bm = beta_maps[trial_idx]
    condition = conditions[trial_idx] if trial_idx < len(conditions) else f"Trial {trial_idx}"

    if 'effect_size' not in bm:
        print("No effect_size found.")
        return

    effect = bm['effect_size']
    left_surf, right_surf = get_surface_paths(derivatives_root, subID)

    if vmax is None:
        all_vals = []
        if hasattr(effect, 'data'):
            for hemi in ['left', 'right']:
                if hemi in effect.data.parts:
                    all_vals.extend(np.abs(effect.data.parts[hemi].flatten()))
        vmax = np.nanpercentile(all_vals, 95) if all_vals else 1.0

    print(f"\nOpening interactive viewer for: {condition}")
    print("(This will open in your default web browser)")

    for hemi in ['left', 'right']:
        surf_mesh = left_surf if hemi == 'left' else right_surf

        if hasattr(effect, 'data') and hemi in effect.data.parts:
            stat_map = effect.data.parts[hemi].flatten()

            view = view_surf(
                surf_mesh,
                surf_map=stat_map,
                cmap='coolwarm',
                symmetric_cmap=True,
                vmax=vmax,
                title=f'{condition} - {hemi.capitalize()} Hemisphere',
            )
            view.open_in_browser()


def list_trials(data: dict):
    """List all trials in the data."""
    # Handle Simple GLM - list contrasts instead of trials
    if data.get('glm_type') == 'simple' and 'contrast_results' in data:
        print(f"\n{'Idx':<5} {'Contrast Name':<40} {'Definition':<40}")
        print("-" * 85)
        for i, (name, result) in enumerate(data['contrast_results'].items()):
            definition = result.get('definition', 'N/A')[:40]
            print(f"{i:<5} {name:<40} {definition:<40}")
        return

    # Handle LSA/LSSM
    conditions = data.get('conditions', [])
    runs = data.get('runs', [])

    if not conditions:
        print("No conditions found in data.")
        return

    print(f"\n{'Idx':<5} {'Run':<5} {'Condition':<60}")
    print("-" * 70)

    for i, cond in enumerate(conditions):
        run = runs[i] if i < len(runs) else '?'
        print(f"{i:<5} {run:<5} {cond:<60}")


def plot_contrast_surface(
    data: dict,
    contrast_name: str,
    derivatives_root: str,
    subID: str,
    map_type: str = 'effect_size',
    save_path: str = None,
    vmax: float = None,
):
    """Plot contrast map on surface for Simple GLM results."""
    try:
        from nilearn.plotting import plot_surf_stat_map
        from nilearn.surface import PolyMesh
    except ImportError:
        print("nilearn plotting not available. Install with: pip install nilearn")
        return

    if data.get('glm_type') != 'simple':
        print("This function is for Simple GLM results. Use --surface for LSA/LSSM.")
        return

    contrast_results = data.get('contrast_results', {})

    if not contrast_results:
        print("No contrast results found.")
        return

    # If contrast_name not specified or not found, use first one
    if contrast_name not in contrast_results:
        available = list(contrast_results.keys())
        if not contrast_name:
            contrast_name = available[0]
            print(f"Using first contrast: {contrast_name}")
        else:
            print(f"Contrast '{contrast_name}' not found. Available: {available}")
            return

    result = contrast_results[contrast_name]
    definition = result.get('definition', contrast_name)

    if map_type not in result or result[map_type] is None:
        print(f"Map type '{map_type}' not available for this contrast.")
        return

    effect = result[map_type]

    # Load surface
    left_surf, right_surf = get_surface_paths(derivatives_root, subID)

    # Determine vmax if not specified
    if vmax is None:
        all_vals = []
        if hasattr(effect, 'data'):
            for hemi in ['left', 'right']:
                if hemi in effect.data.parts:
                    all_vals.extend(np.abs(effect.data.parts[hemi].flatten()))
        if all_vals:
            vmax = np.nanpercentile(all_vals, 95)
        else:
            vmax = 1.0

    # Create figure with both hemispheres
    fig = plt.figure(figsize=(16, 8))
    gs = GridSpec(2, 4, figure=fig, wspace=0.05, hspace=0.1)

    views = [
        ('left', 'lateral', gs[0, 0]),
        ('left', 'medial', gs[0, 1]),
        ('right', 'lateral', gs[1, 0]),
        ('right', 'medial', gs[1, 1]),
    ]

    for hemi, view, grid_pos in views:
        ax = fig.add_subplot(grid_pos, projection='3d')

        if hemi == 'left':
            surf_mesh = left_surf
            if hasattr(effect, 'data') and 'left' in effect.data.parts:
                stat_map = effect.data.parts['left'].flatten()
            else:
                continue
        else:
            surf_mesh = right_surf
            if hasattr(effect, 'data') and 'right' in effect.data.parts:
                stat_map = effect.data.parts['right'].flatten()
            else:
                continue

        try:
            plot_surf_stat_map(
                surf_mesh,
                stat_map,
                hemi=hemi,
                view=view,
                colorbar=False,
                vmax=vmax,
                cmap='coolwarm',
                symmetric_cbar=True,
                axes=ax,
                title=f'{hemi.capitalize()} {view}',
            )
        except Exception as e:
            print(f"Could not plot {hemi} {view}: {e}")

    # Add colorbar
    cax = fig.add_axes([0.55, 0.15, 0.35, 0.03])
    sm = plt.cm.ScalarMappable(cmap='coolwarm', norm=plt.Normalize(-vmax, vmax))
    sm.set_array([])
    cbar = fig.colorbar(sm, cax=cax, orientation='horizontal')
    cbar.set_label(f'{map_type.replace("_", " ").title()}')

    # Title
    fig.suptitle(f'Contrast: {definition}\n({map_type})', fontsize=14, y=0.98)

    if save_path:
        plt.savefig(save_path, dpi=150, bbox_inches='tight')
        print(f"Surface plot saved to: {save_path}")
    else:
        plt.show()


def plot_interactive_contrast(
    data: dict,
    contrast_name: str,
    derivatives_root: str,
    subID: str,
    map_type: str = 'effect_size',
    vmax: float = None,
):
    """Open interactive surface viewer for Simple GLM contrast results."""
    try:
        from nilearn.plotting import view_surf
    except ImportError:
        print("nilearn plotting not available.")
        return

    if data.get('glm_type') != 'simple':
        print("This function is for Simple GLM results.")
        return

    contrast_results = data.get('contrast_results', {})

    if not contrast_results:
        print("No contrast results found.")
        return

    # If contrast_name not specified, use first one
    if not contrast_name or contrast_name not in contrast_results:
        available = list(contrast_results.keys())
        if not contrast_name:
            contrast_name = available[0]
            print(f"Using first contrast: {contrast_name}")
        else:
            print(f"Contrast '{contrast_name}' not found. Available: {available}")
            return

    result = contrast_results[contrast_name]
    definition = result.get('definition', contrast_name)

    if map_type not in result or result[map_type] is None:
        print(f"Map type '{map_type}' not available for this contrast.")
        return

    effect = result[map_type]
    left_surf, right_surf = get_surface_paths(derivatives_root, subID)

    # Determine vmax if not specified
    if vmax is None:
        all_vals = []
        if hasattr(effect, 'data'):
            for hemi in ['left', 'right']:
                if hemi in effect.data.parts:
                    all_vals.extend(np.abs(effect.data.parts[hemi].flatten()))
        vmax = np.nanpercentile(all_vals, 95) if all_vals else 1.0

    print(f"\nOpening interactive viewer for: {definition}")
    print(f"Map type: {map_type}")
    print("(This will open in your default web browser)")

    for hemi in ['left', 'right']:
        surf_mesh = left_surf if hemi == 'left' else right_surf

        if hasattr(effect, 'data') and hemi in effect.data.parts:
            stat_map = effect.data.parts[hemi].flatten()

            view = view_surf(
                surf_mesh,
                surf_map=stat_map,
                cmap='coolwarm',
                symmetric_cmap=True,
                vmax=vmax,
                title=f'{definition} ({map_type}) - {hemi.capitalize()}',
            )
            view.open_in_browser()


def main():
    parser = argparse.ArgumentParser(
        description='Visualize GLM results from pkl files',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Show summary of results
  python visualize_results.py results.pkl --summary

  # Plot design matrices
  python visualize_results.py results.pkl --design-matrices

  # Plot beta histogram
  python visualize_results.py results.pkl --histogram

  # Plot surface for specific trial
  python visualize_results.py results.pkl --surface --trial 5 --subID 073

  # Interactive surface viewer
  python visualize_results.py results.pkl --interactive --trial 5 --subID 073

  # List all trials
  python visualize_results.py results.pkl --list-trials

  # Save plots instead of displaying
  python visualize_results.py results.pkl --histogram --save-dir ./figures/
        """
    )

    parser.add_argument('pkl_file', type=str, help='Path to pkl results file')

    # Visualization options
    parser.add_argument('--summary', action='store_true',
                        help='Print summary statistics')
    parser.add_argument('--design-matrices', action='store_true',
                        help='Plot design matrices')
    parser.add_argument('--histogram', action='store_true',
                        help='Plot beta value histogram')
    parser.add_argument('--surface', action='store_true',
                        help='Plot beta map on surface (LSA/LSSM) or contrast map (Simple GLM)')
    parser.add_argument('--interactive', action='store_true',
                        help='Open interactive surface viewer')
    parser.add_argument('--list-trials', action='store_true',
                        help='List all trials/contrasts in the data')
    parser.add_argument('--all', action='store_true',
                        help='Run all visualizations (summary, design matrices, histogram)')

    # Parameters
    parser.add_argument('--trial', type=int, default=0,
                        help='Trial index for surface plots - LSA/LSSM only (default: 0)')
    parser.add_argument('--contrast', type=str, default=None,
                        help='Contrast name for surface plots - Simple GLM only')
    parser.add_argument('--map-type', type=str, default='effect_size',
                        choices=['effect_size', 'effect_variance', 'z_score'],
                        help='Map type to plot for Simple GLM (default: effect_size)')
    parser.add_argument('--subID', type=str, default='073',
                        help='Subject ID for loading surfaces (default: 073)')
    parser.add_argument('--derivatives', type=str,
                        default='/Users/shawnschwartz/Developer/datasci-homelab/volumes/home/work/amass/derivatives',
                        help='Path to derivatives directory')
    parser.add_argument('--vmax', type=float, default=None,
                        help='Max value for colorbar (default: auto)')
    parser.add_argument('--n-matrices', type=int, default=3,
                        help='Number of design matrices to plot (default: 3)')
    parser.add_argument('--save-dir', type=str, default=None,
                        help='Directory to save figures (default: display)')

    args = parser.parse_args()

    # Check if file exists
    if not os.path.exists(args.pkl_file):
        print(f"Error: File not found: {args.pkl_file}")
        sys.exit(1)

    # Load data
    print(f"Loading: {args.pkl_file}")
    data = load_results(args.pkl_file)

    # Create save directory if needed
    if args.save_dir:
        os.makedirs(args.save_dir, exist_ok=True)
        base_name = os.path.splitext(os.path.basename(args.pkl_file))[0]

    # If no specific option, show summary
    if not any([args.summary, args.design_matrices, args.histogram,
                args.surface, args.interactive, args.list_trials, args.all]):
        args.summary = True

    # Run visualizations
    if args.summary or args.all:
        summarize_results(data, args.pkl_file)

    if args.list_trials:
        list_trials(data)

    if args.design_matrices or args.all:
        save_path = os.path.join(args.save_dir, f'{base_name}_design_matrices.png') if args.save_dir else None
        plot_design_matrices(data, n_matrices=args.n_matrices, save_path=save_path)

    if args.histogram or args.all:
        save_path = os.path.join(args.save_dir, f'{base_name}_histogram.png') if args.save_dir else None
        plot_beta_histogram(data, save_path=save_path)

    if args.surface:
        glm_type = data.get('glm_type', 'unknown')
        if glm_type == 'simple':
            # Simple GLM - plot contrast map
            contrast_name = args.contrast
            if not contrast_name and 'contrast_results' in data:
                contrast_name = list(data['contrast_results'].keys())[0]
            safe_name = contrast_name.replace(' ', '_')[:30] if contrast_name else 'contrast'
            save_path = os.path.join(args.save_dir, f'{base_name}_{safe_name}_{args.map_type}.png') if args.save_dir else None
            plot_contrast_surface(
                data, contrast_name, args.derivatives, args.subID,
                map_type=args.map_type, save_path=save_path, vmax=args.vmax
            )
        else:
            # LSA/LSSM - plot beta map for specific trial
            save_path = os.path.join(args.save_dir, f'{base_name}_surface_trial{args.trial}.png') if args.save_dir else None
            plot_surface_beta(
                data, args.trial, args.derivatives, args.subID,
                save_path=save_path, vmax=args.vmax
            )

    if args.interactive:
        glm_type = data.get('glm_type', 'unknown')
        if glm_type == 'simple':
            plot_interactive_contrast(
                data, args.contrast, args.derivatives, args.subID,
                map_type=args.map_type, vmax=args.vmax
            )
        else:
            plot_interactive_surface(
                data, args.trial, args.derivatives, args.subID,
                vmax=args.vmax
            )


if __name__ == "__main__":
    main()
